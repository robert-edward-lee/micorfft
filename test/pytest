#!/usr/bin/env python
import os
from ctypes import *

import numpy as np
from scipy.fft import irfft, rfft

# Добавление папок из переменной PATH в поиск dll библиотек, т.к. собранная либа
# зависит от dll, находящейся, например, в папке gcc/bin. Подразумевается, что
# она находится где-то в этой переменной.
path = os.environ['PATH']
if os.name == 'nt':
    paths = path.split(';')
elif os.name == 'posix':
    paths = path.split(':')
else:
    print('Error: Unknown OS!')
    exit()
for p in paths:
    if os.path.exists(p):
        os.add_dll_directory(p)


VALID_RFFT_SIZES = [
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096,
]


class Test(object):
    EPSILON = 1e-4
    dll = CDLL('./c_wrapper.dll')

    def __init__(self, size: int):
        if size not in VALID_RFFT_SIZES:
            print(f'size == {size}, expected one of {VALID_RFFT_SIZES}')
            return

        self._size = size
        self._real_data = (c_float * self._size)()
        self._complex_data = (c_float * self._size)()
        self._c_fft = getattr(self.dll, f'rfft_forward_{self._size}_f32')
        self._c_ifft = getattr(self.dll, f'rfft_inverse_{self._size}_f32')

    def forward_test(self, data_t, data_f):
        # print('data:')
        # print(data_t)

        for i in range(self._size):
            self._real_data[i] = data_t[i]

        self._c_fft(self._real_data, self._complex_data)
        testing_data = np.array(
            self._complex_data, dtype=np.float32).view(np.complex64)
        # print('mf:')
        # print(testing_data)

        print(f'test for rfft<{self._size}>::forward ... ', end='')
        mismatches = 0
        for i in range(testing_data.size):
            xn = testing_data[i]
            ref = data_f[i]

            if abs(xn - ref) > self.EPSILON:
                print(f'[{i:03}]: {xn} != {ref}')
                mismatches += 1
        print(f'{'passed' if not mismatches else f'failed, {
              mismatches} mismatches'}')
        return mismatches

    def inverse_test(self, data_t, data_f):
        # print('data:')
        # print(data_f)

        for i in range(self._size // 2):
            self._complex_data[2 * i] = data_f[i].real
            self._complex_data[2 * i + 1] = data_f[i].imag

        self._c_ifft(self._complex_data, self._real_data)
        testing_data = np.array(
            self._complex_data, dtype=np.float32).view(np.complex64)
        # print('mf:')
        # print(testing_data)

        print(f'test for rfft<{self._size}>::inverse ... ', end='')
        mismatches = 0
        for i in range(testing_data.size // 2):
            xn = testing_data[i]
            ref = data_f[i]

            if abs(xn - ref) > self.EPSILON:
                print(f'[{i:03}]: {xn} != {ref}')
                mismatches += 1
        print(f'{'passed' if not mismatches else f'failed, {
              mismatches} mismatches'}')
        return mismatches

    def test(self, data_t):
        data_f = rfft(data_t)

        self.forward_test(data_t, data_f[:-1])  # cutdown Nyquist frequency

        self.inverse_test(data_t, data_f)


for size in VALID_RFFT_SIZES:
    test = Test(size)

    x = np.random.rand(size).astype(np.float32)
    test.test(x)
